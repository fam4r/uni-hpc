\section{Sviluppo}

Entrambe le soluzioni proposte si avvalgono dell'utilizzo di una ghost area
inizializzata a zero (e mai più modificata).
Ciò permette di snellire notevolmente l'impatto sulle prestazioni
dell'operazione di propagazione, poiché, essendoci una regione di intorno
(\textit{halo}) al dominio, non sarà più necessario controllare che le celle
adiacenti a quella presa in esame siano ai bordi del dominio stesso.

É stato inizialmente ipotizzato l'accesso alla matrice considerandola come un
array, in accordo con la rappresentazione in memoria delle matrici fornita dal
linguaggio C.
Ciò avrebbe permesso di scorrere in modo sequenziale la matrice stessa,
risparmiando le chiamate alla funzione \texttt{IDX}.

Ad esempio, l'operazione di incremento di energia sarebbe stata implementata nel
seguente modo:
\begin{minted}{c}
for (int i = 0; i < n; i++) {
    grid[i] += delta;
}
\end{minted}

Tuttavia, l'introduzione della ghost area atta a ridurre l'impatto di
prestazioni in altre aree della soluzione proposta ha reso preferibile (in
termini di gestione dell'accesso alla memoria) l'utilizzo della funzione
\texttt{IDX}, che contribuisce inoltre ad una buona comprensione e leggibilità
del codice sorgente.

\subsection{Implementazione OpenMP}

L'inizializzazione della ghost area a zero non è stata parallelizzata poiché i
test effettuati hanno mostrato un degradamento, seppur minimo, delle
prestazioni.

\begin{center}
\begin{tabular}{ccc}
 \hline
 Lato dominio & Numero passi & T\textsubscript{setup} (\textit{s})\\
 \hline
 512 & 1000 & 0.00337177\\
 512 & 1000 & 0.00454419\\
 \hline
\end{tabular}
\end{center}

Tale comportamento può essere dovuto ad un ulteriore carico di lavoro assegnato
allo scheduler per un'attività che mal si presta (soprattutto per l'accesso ai
lati sinistro e destro del dominio a causa dell'accesso in memoria) ad essere
parallelizzata.

\subsection{Implementazione CUDA}

Il dominio è stato partizionato, come da suggerimenti, in blocchi 2D organizzati
a loro volta in griglie 2D.

Per le operazioni effettuate nelle funzioni \texttt{count\_cells} e
\texttt{average\_energy} il dominio è stato invece partizionato in blocchi
monodimensionali, in accordo con la rappresentazione matriciale nel linguaggio
di programmazione C.

A tal proposito, per le sopracitate operazioni, è stata opportunamente
implementata l'operazione di riduzione mediante operatore somma.

In un primo momento, per semplicità, si è proceduto con la realizzazione della
soluzione senza l'utilizzo della memoria condivisa del Device.
